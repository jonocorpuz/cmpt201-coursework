/*
Questions to answer at top of client.c:
(You should not need to change the code in client.c)

1. What is the address of the server it is trying to connect to (IP address
 ┆  and 5 port number). Address: 127.0.0.1, Port: 8000

2. Is it UDP or TCP? How do you know?
This is TCP becuase the code uses "connect", which not something present in
UDP code. Since, UDP is connectionless, it lacks an explicit "connection"
between client and server, it does not have a connect call in its
implementation.

3. The client is going to send some data to the server. Where does it get this
data from? How can you tell in the code?
The client is sending data from standard input. The line: num_read =
read(STDIN_FILENO, buf, BUF_SIZE)) > 1, reads input from stdin and sends it
to a buffer that is written to the server via the socker sfd.

4. How does the client program end? How can you tell that in the code?
The clients program ends when close(sfd) is called. It means that the socket
is closed and thus, the connection between the server and client has terminated.
*/

#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

#define PORT 8000
#define BUF_SIZE 64
#define ADDR "127.0.0.1"

#define handle_error(msg)                                                      \
  do {                                                                         \
    perror(msg);                                                               \
    exit(EXIT_FAILURE);                                                        \
  } while (0)

int main() {
  struct sockaddr_in addr;
  int sfd;
  ssize_t num_read;
  char buf[BUF_SIZE];

  sfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sfd == -1) {
    handle_error("socket");
  }

  memset(&addr, 0, sizeof(struct sockaddr_in));
  addr.sin_family = AF_INET;
  addr.sin_port = htons(PORT);
  if (inet_pton(AF_INET, ADDR, &addr.sin_addr) <= 0) {
    handle_error("inet_pton");
  }

  int res = connect(sfd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in));
  if (res == -1) {
    handle_error("connect");
  }

  while ((num_read = read(STDIN_FILENO, buf, BUF_SIZE)) > 1) {
    if (write(sfd, buf, num_read) != num_read) {
      handle_error("write");
    }
    printf("Just sent %zd bytes.\n", num_read);
  }

  if (num_read == -1) {
    handle_error("read");
  }

  close(sfd);
  exit(EXIT_SUCCESS);
}

#include <arpa/inet.h>
#include <errno.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

#define BUF_SIZE 64
#define PORT 8000
#define LISTEN_BACKLOG 32

#define handle_error(msg)                                                      \
  ┆ do {                                                                       \
    ┆ ┆ perror(msg);                                                           \
    ┆ ┆ exit(EXIT_FAILURE);                                                    \
  }                                                                            \
  while (0)

// Shared counters for: total # messages, and counter of clients (used for
// assigning client IDs)
int total_message_count = 0;
int client_id_counter = 1;

// Mutexs to protect above global state.
pthread_mutex_t count_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t client_id_mutex = PTHREAD_MUTEX_INITIALIZER;

struct client_info {
  int cfd;
  int client_id;
};

void *handle_client(void *arg) {
  struct client_info *client = (struct client_info *)arg;

  // TODO: print the message received from client
  char buf[BUF_SIZE];
  int num_bytes = read(client->cfd, buf, BUF_SIZE);

  buf[num_bytes] = 0;
  printf("Client ID: %d, Message Count: %d, Message: %s\n", client->client_id,
         total_message_count, buf);

  // TODO: increase total_message_count per message
  total_message_count++;

  return NULL;
}

int main() {
  struct sockaddr_in addr;
  int sfd;

  sfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sfd == -1) {
    handle_error("socket");
  }

  memset(&addr, 0, sizeof(struct sockaddr_in));
  addr.sin_family = AF_INET;
  addr.sin_port = htons(PORT);
  addr.sin_addr.s_addr = htonl(INADDR_ANY);

  if (bind(sfd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in)) == -1) {
    handle_error("bind");
  }

  if (listen(sfd, LISTEN_BACKLOG) == -1) {
    handle_error("listen");
  }

  int thread_count = 0;
  pthread_t threads[1024];

  for (;;) {
    // TODO: create a new thread when a new connection is encountered
    struct sockaddr_in client_addr;
    socklen_t client_len = sizeof(client_addr);
    int cfd = accept(sfd, (struct sockaddr *)&client_addr, &client_len);
    if (cfd == -1) {
      handle_error("accept");
    }

    struct client_info *client = malloc(sizeof(struct client_info));
    client->cfd = cfd;
┆ ┆
    pthread_mutex_lock(&client_id_mutex);
    { client->client_id = client_id_counter++; }
    pthread_mutex_unlock(&client_id_mutex);

    printf("Client ID: %d\n", client->client_id);

    // TODO: call handle_client() when launching a new thread, and provide
    pthread_create(&threads[thread_count], NULL, handle_client, (void *)client);
    thread_count++;
  }

  if (close(sfd) == -1) {
    handle_error("close");
  }

  for (int i = 0; i < thread_count; i++) {
    pthread_join(threads[i], NULL);
  }
  return 0;
}
